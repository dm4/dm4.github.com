<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux | blog.dm4.tw]]></title>
  <link href="http://blog.dm4.tw/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://blog.dm4.tw/"/>
  <updated>2015-03-18T12:51:11+08:00</updated>
  <id>http://blog.dm4.tw/</id>
  <author>
    <name><![CDATA[dm4]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用 xxd 解 Hex String]]></title>
    <link href="http://blog.dm4.tw/blog/2013/11/08/yong-xxd-jie-hex-string/"/>
    <updated>2013-11-08T13:57:00+08:00</updated>
    <id>http://blog.dm4.tw/blog/2013/11/08/yong-xxd-jie-hex-string</id>
    <content type="html"><![CDATA[<p>本來解 hex string 都是用有點醜的 perl one-liner</p>

<p><code>
$ perl -ne 'print map chr hex, m/../g' &lt;&lt;&lt; 646d340a
dm4
</code></p>

<p>不過昨天又研究了一下 <code>xxd</code> 發現一些神秘的功能，像是發現有 C style 的 output ！</p>

<p><code>
$ xxd -i data
unsigned char data[] = {
  0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x62, 0x69, 0x61, 0x6e,
  0x72, 0x79, 0x3f, 0x0a
};
unsigned int data_len = 16;
</code></p>

<p>還可以調 column 數</p>

<p><code>
$ xxd -i -c 8 data
unsigned char data[] = {
  0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,
  0x62, 0x69, 0x61, 0x6e, 0x72, 0x79, 0x3f, 0x0a
};
unsigned int data_len = 16;
</code></p>

<p>然後 <a href="http://blog.atdog.org">atdog</a> 大大看到之後，又教了我怎麼用 <code>xxd</code> 解 hex string</p>

<ul>
<li>生 hex string</li>
</ul>


<p><code>
$ xxd -p &lt;&lt;&lt; dm4
646d340a
</code></p>

<ul>
<li>解 hex string</li>
</ul>


<p><code>
$ xxd -p -r &lt;&lt;&lt; 646d340a
dm4
</code></p>

<p>太帥了！而且比原本 perl one-liner 短好多啊啊啊</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Command Line 小知識]]></title>
    <link href="http://blog.dm4.tw/blog/2013/01/27/command-line-xiao-zhi-shi/"/>
    <updated>2013-01-27T22:35:00+08:00</updated>
    <id>http://blog.dm4.tw/blog/2013/01/27/command-line-xiao-zhi-shi</id>
    <content type="html"><![CDATA[<p>前幾天看了這篇 <a href="http://geekblog.oneandoneis2.org/index.php/2012/09/30/to-understand-the-command-line">To understand the command line&hellip;</a> 覺得蠻有趣的，大概是在說：</p>

<ul>
<li><code>awk</code>: 作者名字的縮寫</li>
<li><code>cat</code>: concatenate</li>
<li><code>more</code>: 螢幕最下面會顯示 &ldquo;More&rdquo;</li>
<li><code>less</code>: more 的加強版，因為 &ldquo;less is more&rdquo; 所以叫 less</li>
<li><code>ed</code>: editor</li>
<li><code>sed</code>: stream editor</li>
<li><code>grep</code>: 在 <code>ed</code> 裡要找有包含特定字串的行並印出，本來是要用 <code>g/regular expression/p</code> ，簡寫成 <code>g/re/p</code> 就變成 <code>grep</code> 了</li>
<li>hjkl 方向鍵是因為 <a href="http://www.catonmat.net/blog/why-vim-uses-hjkl-as-arrow-keys/">ADM-3A</a></li>
<li><code>~</code> 代表 HOME 也是因為 <a href="http://www.catonmat.net/blog/why-vim-uses-hjkl-as-arrow-keys/">ADM-3A</a></li>
<li><code>.</code> 開頭的檔案是隱藏檔，本來只是要跳過 <code>.</code> 和 <code>..</code> ，結果寫出有 bug 的 <code>if (name[0] == '.') continue;</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[.bashrc sourced twice]]></title>
    <link href="http://blog.dm4.tw/blog/2012/05/11/dot-bashrc-sourced-twice/"/>
    <updated>2012-05-11T21:08:00+08:00</updated>
    <id>http://blog.dm4.tw/blog/2012/05/11/dot-bashrc-sourced-twice</id>
    <content type="html"><![CDATA[<p>昨天解決了困擾了一陣子的問題，在 <code>.bashrc</code> 裡，如果有改到 <code>$PATH</code> ：</p>

<pre><code>export PATH=~/bin:$PATH
</code></pre>

<p>又因為我會用到 <a href="http://tmux.sourceforge.net/">tmux</a> ，所以在 <code>tmux</code> 裡開新的 shell 時，會再 source 一次 <code>.bashrc</code> ，本來我的解法是這樣：</p>

<pre><code>[ -z "$TMUX" ] &amp;&amp; export PATH=~/bin:$PATH
</code></pre>

<p>也就是在 <code>tmux</code> 裡新開啟的 shell 並不會再改一次 <code>$PATH</code> ，可是這樣又遇到了另一個問題：當新的 shell 打開時，本來應該被加在前面的 <code>~/bin</code> 會被接到後面去，我在想應該是開新 shell 時 bash 自己做的處理，我在 <code>/etc/bashrc</code> 裡也沒有看到相關的 script 。</p>

<p>對於這個問題我最後的解法是參考 <a href="http://perlbrew.pl/">perlbrew</a> 裡的這段 script ：</p>

<pre><code>export PATH_WITHOUT_PERLBREW="$(perl -e 'print join ":", grep { index($_, $ENV{PERLBREW_ROOT}) } split/:/,$ENV{PATH};')"

if [[ -z "$PERLBREW_PATH" ]]; then
    export PERLBREW_PATH="$PERLBREW_ROOT/bin"
fi

export PATH="$PERLBREW_PATH:$PATH_WITHOUT_PERLBREW"
</code></pre>

<p>最後的結果：</p>

<pre><code>export PATH="~/bin:$(perl -e 'print join ":", grep { $_ ne "~/bin" } split/:/, $ENV{PATH};')"
</code></pre>

<p><strong>Update</strong> 2012-05-13</p>

<p>為了避免 <code>~/bin</code> 和 <code>$HOME/bin</code> 混用，所以改了一下 script</p>

<pre><code>export PATH=$HOME/bin:"$(perl -e 'print join ":", grep { $_ ne "$ENV{HOME}/bin" &amp;&amp; $_ ne "~/bin" } split/:/, $ENV{PATH};')"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[ and [[ in shell script]]></title>
    <link href="http://blog.dm4.tw/blog/2012/05/10/and-in-shell-script/"/>
    <updated>2012-05-10T17:01:00+08:00</updated>
    <id>http://blog.dm4.tw/blog/2012/05/10/and-in-shell-script</id>
    <content type="html"><![CDATA[<p>終於搞懂在 shell script 裡 <code>[ ... ]</code> 和 <code>[[ ... ]]</code> 的差別了</p>

<pre><code>$ help [
[: [ arg... ]
    This is a synonym for the "test" builtin, but the last
    argument must be a literal `]', to match the opening `['.
[[ ... ]]: [[ expression ]]
    Returns a status of 0 or 1 depending on the evaluation of the conditional
    expression EXPRESSION.  Expressions are composed of the same primaries used
    by the `test' builtin, and may be combined using the following operators

        ( EXPRESSION )  Returns the value of EXPRESSION
        ! EXPRESSION    True if EXPRESSION is false; else false
        EXPR1 &amp;&amp; EXPR2  True if both EXPR1 and EXPR2 are true; else false
        EXPR1 || EXPR2  True if either EXPR1 or EXPR2 is true; else false

    When the `==' and `!=' operators are used, the string to the right of the
    operator is used as a pattern and pattern matching is performed.  The
    &amp;&amp; and || operators do not evaluate EXPR2 if EXPR1 is sufficient to
    determine the expression's value.
</code></pre>

<p>簡單的說就是要用 <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>, <code>()</code> 的話要用 <code>[[ ... ]]</code></p>
]]></content>
  </entry>
  
</feed>
